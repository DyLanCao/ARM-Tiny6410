insmod
====
参考: [LLD3 - 2.4. 编译和加载](http://oss.org.cn/kernel-book/ldd3/ch02s04.html)


模块编译完成之后, 下一步是加载到内核。
通过insmod加载模块:

	$ sudo insmod hello.ko

###insmod的工作:

1. 加载模块的代码段和数据段到内核
2. 解析符号。执行一个类似 ld 的函数, 它**连接模块中任何未解决的符号(模块代码中未定义的函数名、未定义的变量等)连接到内核的符号表上**。但是不象连接器, 内核不修改模块的磁盘文件, 而是内存内的拷贝。(即连接器解析符号以后生成解析好的文件，下次不再需要ld解析，而内核是每次插入模块都要重新解析）。
3. 传递参数。insmod 接收许多命令行选项(详情见 manpage), 它能够安排值给你模块中的参数, 在连接到当前内核之前。 因此, 如果一个模块正确设计了, 它能够在加载时配置; 加载时配置比编译时配置给了用户更多的灵活性, 有时仍然在用。


###内核如何支持 insmod:
insmod依赖一个在 `kernel/module.c` 中定义的系统调用。

函数 `sys_init_module` 分配内核内存来存放模块 ( 这个内存用 vmalloc 分配); 它接着拷贝模块的代码段到这块内存区, 借助内核符号表解决模块中的内核引用, 并且调用模块的初始化函数来启动所有东西.

如果你真正看了内核代码, 你会发现系统调用的名子以 sys_ 为前缀. 这对所有系统调用都是成立的, 并且没有别的函数. 记住这个有助于在源码中查找系统调用.

###modprobe
modprobe 工具值得快速提及一下. modprobe, 如同 insmod, 加载一个模块到内核. 它的不同在于它会查看要加载的模块, 看是否它引用了当前内核没有定义的符号. 如果发现有, modprobe 在定义相关符号的当前模块搜索路径中寻找其他模块. 当 modprobe 找到这些模块( 要加载模块需要的 ), 它也把它们加载到内核. 如果你在这种情况下代替以使用 insmod , 命令会失败, 在系统日志文件中留下一条 " unresolved symbols "消息.

###rmmod
如前面提到, 模块可以用 rmmod 工具从内核去除. 注意, 如果内核认为模块还在用( 就是说, 一个程序仍然有一个打开文件对应模块输出的设备 ), 或者内核被配置成不允许模块去除, 模块去除会失败. 可以配置内核允许"强行"去除模块, 甚至在它们看来是忙的. 如果你到了需要这选项的地步, 但是, 事情可能已经错的太严重以至于最好的动作就是重启了.

	$ sudo rmmod hello

###lsmod
lsmod 程序生成一个内核中当前加载的模块的列表. 一些其他信息, 例如使用了一个特定模块的其他模块, 也提供了. lsmod 通过读取 /proc/modules 虚拟文件工作. 当前加载的模块的信息也可在位于 /sys/module 的 sysfs 虚拟文件系统找到.